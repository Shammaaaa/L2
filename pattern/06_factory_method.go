package pattern

import (
	"log"
)

type action string

const (
	A action = "A"
	B action = "B"
	C action = "C"
)

type Creator interface {
	CreateProduct(action action) Product1 // Factory Method
}

type Product1 interface {
	Use() string // Every product should be usable
}

type ConcreteCreator struct{}

func NewCreator() Creator {
	return &ConcreteCreator{}
}

func (p *ConcreteCreator) CreateProduct(action action) Product1 {
	var product Product1

	switch action {
	case A:
		product = &ConcreteProductA{string(action)}
	case B:
		product = &ConcreteProductB{string(action)}
	case C:
		product = &ConcreteProductC{string(action)}
	default:
		log.Fatalln("Unknown Action")
	}

	return product
}

type ConcreteProductA struct {
	action string
}

func (p *ConcreteProductA) Use() string {
	return p.action
}

type ConcreteProductB struct {
	action string
}

func (p *ConcreteProductB) Use() string {
	return p.action
}

type ConcreteProductC struct {
	action string
}

func (p *ConcreteProductC) Use() string {
	return p.action
}

/*
Паттерн "фабричный метод" применяется, когда у вас есть иерархия классов, а процесс создания объектов различных подклассов должен быть обобщенным.
Вместо того, чтобы явно создавать объекты определенного подкласса, паттерн фабричного метода предлагает вынести эту логику в отдельный метод-фабрику,
который будет создавать экземпляры классов, реализующих общий интерфейс или абстрактный класс.

Плюсы использования паттерна фабричный метод:

1. Устранение зависимостей: Паттерн фабричного метода позволяет создавать объекты через их общий интерфейс или абстрактный класс.
Это уменьшает зависимость от конкретных классов и облегчает замену реализации без внесения изменений в клиентский код.
2. Расширяемость: Паттерн фабричного метода упрощает добавление новых подклассов и расширение функциональности системы,
не изменяя существующий код. Достаточно создать новый подкласс и добавить соответствующий метод-фабрику.
3. Повышение гибкости: Фабричный метод позволяет выбирать конкретный подкласс объекта во время выполнения программы,
в зависимости от определенных условий или конфигурации.
4. Улучшение тестируемости: Паттерн фабричного метода позволяет легко мокировать или подменять создаваемые объекты при проведении модульных тестов,
что упрощает тестирование и увеличивает его надежность.

Некоторые возможные минусы паттерна фабричный метод:

1. Усложнение структуры кода: Использование паттерна фабричного метода может привести к добавлению дополнительных классов и увеличению сложности структуры кода,
особенно в случае больших иерархий классов.
2. Увеличение объема кода: Паттерн фабричного метода требует создания отдельного класса-фабрики для каждого подкласса, что может привести к увеличению объема кода.
3. Отсутствие отношения "один к одному": Фабричный метод не всегда гарантирует соответствие одного фабричного метода одному конкретному классу,
что может затруднить понимание логики системы и усложнить поддержку.

Необходимость использования паттерна фабричный метод зависит от конкретной ситуации и требований проекта.
Он особенно полезен, когда у вас есть иерархия классов и вам нужно создавать объекты этих классов через единый интерфейс или абстрактный класс,
обеспечивая гибкость и расширяемость системы.
*/
