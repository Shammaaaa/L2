package pattern

type Handler interface {
	SendRequest(message int) string
}

type ConcreteHandlerA struct {
	next Handler
}

func (h *ConcreteHandlerA) SendRequest(message int) (result string) {
	if message == 1 {
		result = "Im handler 1"
	} else if h.next != nil {
		result = h.next.SendRequest(message)
	}
	return
}

type ConcreteHandlerB struct {
	next Handler
}

func (h *ConcreteHandlerB) SendRequest(message int) (result string) {
	if message == 2 {
		result = "Im handler 2"
	} else if h.next != nil {
		result = h.next.SendRequest(message)
	}
	return
}

type ConcreteHandlerC struct {
	next Handler
}

func (h *ConcreteHandlerC) SendRequest(message int) (result string) {
	if message == 3 {
		result = "Im handler 3"
	} else if h.next != nil {
		result = h.next.SendRequest(message)
	}
	return
}

/*
Паттерн "цепочка ответственности" применяется, когда у вас есть набор объектов, которые могут обработать запрос,
но вы не знаете заранее, какой конкретный объект сможет это сделать.
Вместо того, чтобы явно связывать отправителя запроса с получателем, паттерн позволяет создать цепочку объектов, где каждый объект может решить,
имеет ли он возможность обработать запрос или должен передать его дальше по цепочке.
Плюсы использования паттерна "цепочка ответственности" включают:

1. Гибкость и расширяемость: Паттерн позволяет гибко настраивать порядок обработки запросов путем добавления или удаления объектов в цепочке.
Это упрощает внесение изменений в систему без необходимости изменения множества классов.
2. Отделение отправителя от получателя: Паттерн "цепочка ответственности" позволяет отделить отправителя запроса от конкретного получателя,
что упрощает код и делает его более гибким при изменении логики обработки запросов.
3. Возможность обработки либо запуска всех запросов: За счет создания цепочки вы можете добиться того,
чтобы запрос был обработан подходящим объектом в цепочке или же ни один объект не обработал его. Это позволяет гибко управлять обработкой запросов.

Некоторые возможные минусы паттерна "цепочка ответственности":

1. Необходимость обеспечения корректной настройки цепочки: Если цепочка не настроена правильно или нет явного завершающего объекта,
запрос может остаться необработанным или наоборот, будет проходить через все объекты, что приведет к потере производительности.
2. Потенциальная сложность отладки: Поскольку запрос может пройти через несколько объектов, может быть сложно отследить,
какой именно объект обработал или не обработал запрос.

Необходимость использования паттерна "цепочка ответственности" зависит от контекста задачи. Этот паттерн полезен в случаях, когда у вас есть группа объектов,
каждый из которых может обработать запрос по-своему, и вы хотите, чтобы запрос автоматически передавался по цепочке объектов до тех пор,
пока не будет обработан или пока не достигнут конец цепочки.
*/
