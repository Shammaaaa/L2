package pattern

type StrategySort interface {
	Sort([]int)
}

type BubbleSort struct {
}

func (s *BubbleSort) Sort(a []int) {
	size := len(a)
	if size < 2 {
		return
	}
	for i := 0; i < size; i++ {
		for j := size - 1; j >= i+1; j-- {
			if a[j] < a[j-1] {
				a[j], a[j-1] = a[j-1], a[j]
			}
		}
	}
}

type InsertionSort struct {
}

func (s *InsertionSort) Sort(a []int) {
	size := len(a)
	if size < 2 {
		return
	}
	for i := 1; i < size; i++ {
		var j int
		var buff = a[i]
		for j = i - 1; j >= 0; j-- {
			if a[j] < buff {
				break
			}
			a[j+1] = a[j]
		}
		a[j+1] = buff
	}
}

type Context struct {
	strategy StrategySort
}

func (c *Context) Algorithm(a StrategySort) {
	c.strategy = a
}

func (c *Context) Sort(s []int) {
	c.strategy.Sort(s)
}

/*
Паттерн "стратегия" применяется, когда у вас есть различные варианты алгоритмов или поведения, которые могут быть выбраны во время выполнения программы.
С помощью этого паттерна вы можете вынести каждый вариант в отдельный класс стратегии,
а затем динамически выбирать и использовать нужную стратегию в зависимости от ситуации.

Плюсы использования паттерна "стратегия":

1. Устранение дублирования кода: Паттерн "стратегия" позволяет вынести общую часть алгоритмов в общий интерфейс или абстрактный класс.
Это устраняет дублирование кода и повторное написание алгоритмов для каждого варианта.
2. Гибкость и расширяемость: Паттерн "стратегия" обеспечивает гибкость и расширяемость системы, позволяя добавлять новые стратегии без изменения существующего кода.
Вы можете легко добавить новые классы стратегий и использовать их вместе с уже существующими.
3. Разделение ответственностей: Стратегии позволяют разделить определение алгоритмов и их использование.
Клиентский код работает с общим интерфейсом стратегии, не зная о конкретных реализациях, что упрощает поддержку и позволяет легко менять стратегии в будущем.

Некоторые возможные минусы паттерна "стратегия":

1. Усложнение структуры кода: Использование паттерна "стратегия" может привести к добавлению дополнительных классов и сложности структуры кода,
особенно если у вас большое количество стратегий.
2. Увеличение объема кода: Для каждого варианта алгоритма требуется создание отдельного класса стратегии, что может привести к увеличению объема кода.
3. Динамическое определение стратегии: Если часто требуется менять стратегию во время выполнения программы,
это может привести к дополнительной сложности и усложнить отладку и понимание программы.

Несмотря на возможные минусы, паттерн "стратегия" является мощным инструментом для управления различными вариантами алгоритмов
и обеспечения гибкости и расширяемости системы.
*/
