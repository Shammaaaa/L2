package pattern

type MobileAlertStater interface {
	Alert() string
}

type MobileAlert struct {
	state MobileAlertStater
}

func (a *MobileAlert) Alert() string {
	return a.state.Alert()
}

func (a *MobileAlert) SetState(state MobileAlertStater) {
	a.state = state
}

func NewMobileAlert() *MobileAlert {
	return &MobileAlert{state: &MobileAlertVibration{}}
}

type MobileAlertVibration struct {
}

func (a *MobileAlertVibration) Alert() string {
	return "Vrrr... Brrr... Vrrr..."
}

type MobileAlertSong struct {
}

func (a *MobileAlertSong) Alert() string {
	return "Белые розы, Белые розы. Беззащитны шипы..."
}

/*
Паттерн "Состояние" применяется, когда объект должен изменять свое поведение в зависимости от своего внутреннего состояния.
Он позволяет моделировать сложное поведение объектов, разбивая его на отдельные состояния и определяя переходы между ними.

Плюсы использования паттерна "Состояние":

1. Расширяемость и гибкость: Паттерн "Состояние" обеспечивает гибкость и расширяемость, позволяя добавлять новые состояния и легко изменять поведение объекта.
Каждое состояние может быть реализовано в отдельном классе, что упрощает добавление новых состояний без изменения существующего кода.

2. Упрощение кода: Паттерн "Состояние" позволяет упростить код объекта, разделяя его на отдельные классы состояний.
Каждое состояние содержит свое собственное поведение и переходы, что делает код более модульным и понятным.

3. Соблюдение принципа открытости/закрытости: Паттерн "Состояние" позволяет придерживаться принципа открытости/закрытости.
Вы можете добавлять новые состояния, не изменяя кода существующих состояний или самого объекта. Это упрощает поддержку и расширение системы.

Некоторые возможные минусы паттерна "Состояние":

1. Усложнение структуры кода: Использование паттерна "Состояние" может привести к увеличению количества классов и усложнению структуры кода.
Каждое состояние требует своего класса, что может привести к повышению сложности понимания и поддержки кода.

2. Управление контекстом и переходами: Управление состояниями и переходами между ними может быть сложной задачей.
Необходимо обеспечить правильное переключение состояний и учесть возможные переходы в разных контекстах.
Это может привести к дополнительной сложности и требовать тщательного проектирования.

3. Увеличение объема кода: Каждое состояние требует своей собственной реализации, что может привести к увеличению объема кода.
Если количество состояний велико, это может стать проблемой.

Несмотря на возможные минусы, паттерн "Состояние" помогает управлять сложным поведением объектов,
делает код более модульным и позволяет легко добавлять новые состояния или изменять поведение объекта.
Он особенно полезен, когда объект имеет много различных состояний и требует динамического переключения между ними.
*/
